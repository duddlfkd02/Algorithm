/* ðŸ§  ë¬¸ì œ ì„¤ëª…

ê°ì²´ í˜•íƒœë¡œ í‘œí˜„ëœ ê·¸ëž˜í”„(graph)ì™€ ì‹œìž‘ ë…¸ë“œ(start)ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
ê¹Šì´ ìš°ì„  íƒìƒ‰(DFS)ì„ ì‚¬ìš©í•´ì„œ, ì‹œìž‘ ë…¸ë“œì—ì„œë¶€í„° ë°©ë¬¸í•œ ìˆœì„œëŒ€ë¡œ ë…¸ë“œ ì´ë¦„ì„ ë°°ì—´ì— ë‹´ì•„ ë°˜í™˜í•˜ì„¸ìš”.
ì´ë¯¸ ë°©ë¬¸í•œ ë…¸ë“œëŠ” ë‹¤ì‹œ ë°©ë¬¸í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.



âœ… ìž…ì¶œë ¥
	1.	graph: { [node: string]: string[] }
	  â€¢	ê° í‚¤ê°€ ë…¸ë“œ ì´ë¦„, ê°’ì´ ê·¸ ë…¸ë“œì™€ ì—°ê²°ëœ ì´ì›ƒ ë…¸ë“œë“¤ì˜ ë°°ì—´ìž…ë‹ˆë‹¤.
	2.	start: DFSë¥¼ ì‹œìž‘í•  ë…¸ë“œ ì´ë¦„(ë¬¸ìžì—´)

  	â€¢	DFSë¡œ ë°©ë¬¸í•œ ìˆœì„œëŒ€ë¡œ ë…¸ë“œ ì´ë¦„ì„ ë‹´ì€ ë°°ì—´


  const graph = {
    A: ['B', 'C'],
    B: ['D', 'E'],
    C: ['F'],
    D: [],
    E: [],
    F: []
  };
  const start = 'A';

  // DFS ë°©ë¬¸ ìˆœì„œ: A â†’ B â†’ D â†’ E â†’ C â†’ F
  output: ['A', 'B', 'D', 'E', 'C', 'F']
*/

/**
 * ì ‘ê·¼ë°©ì‹
 * startë¶€í„° ì‹œìž‘í•´ì„œ ì¸ì ‘ ë…¸ë“œ ë°©ë¬¸
 * "A" -> "B"ë¡œ ê°”ë‹¤ë©´, "B" ìž¬ê·€ ì‹œìž‘
 * "B"ì˜ ì´ì›ƒ "D" í™•ì¸ -> "D"ëŠ” ì´ì›ƒì´ ì—†ìœ¼ë¯€ë¡œ ë‹¤ì‹œ "B"ë¡œ ëŒì•„ì™€ ë‹¤ìŒ ì´ì›ƒ "E" í™•ì¸
 * "E"ë„ ì—†ê³  "B"ë„ ëª¨ë‘ í™•ì¸í–ˆìœ¼ë¯€ë¡œ "A" í™•ì¸
 *
 * visited ë°©ë¬¸ ìˆœì„œ ë‹´ëŠ” ë°°ì—´
 * check ë°©ë¬¸í•œ ë…¸ë“œ í‘œì‹œìš© ë³€ìˆ˜
 */

const graph = {
  A: ["B", "C"],
  B: ["D", "E"],
  C: ["F"],
  D: [],
  E: [],
  F: [],
};

const start = "A";

function solution(graph, start) {
  const seen = new Set();
  const visited = [];

  const dfs = (index) => {
    if (seen.has(index)) return;

    seen.add(index);
    visited.push(index);

    for (const next of graph[index]) {
      dfs(next);
    }
  };
  dfs(start);
  return visited;
}

console.log(solution(graph, start));
